<h1 id="pointers-in-c--c">Pointers in C / C++</h1>

<p>Pointer is the most notorious but most powerful syntax/keyword in C/C++.
Although the concept of pointer is simple that pointer simply points to something.
As pointer can points actually everything and it could work outside of code scopes, it causes complexities.
In addition to this, with combining dynamic memory allocation (heap allocation), it often causes serious problem in memory leakages, dangling pointer, buffer overflow and securities (e.g. stack smashing).</p>

<details open="">
  <summary class="text-delta">
    Table of contents
  </summary>
<ul id="markdown-toc">
  <li><a href="#pointers-in-c--c" id="markdown-toc-pointers-in-c--c">Pointers in C / C++</a>    <ul>
      <li><a href="#basic-pointer" id="markdown-toc-basic-pointer">Basic Pointer</a></li>
      <li><a href="#dynamic-allocation-with-pointers" id="markdown-toc-dynamic-allocation-with-pointers">Dynamic Allocation with Pointers</a></li>
      <li><a href="#c-style-dynamic-allocation" id="markdown-toc-c-style-dynamic-allocation">C-style Dynamic Allocation</a></li>
      <li><a href="#c---raii-dynamic-allocation" id="markdown-toc-c---raii-dynamic-allocation">C++ - RAII Dynamic Allocation</a></li>
    </ul>
  </li>
</ul>

</details>

<h2 id="basic-pointer">Basic Pointer</h2>
<p>Here’s C / C++ basic raw-pointer. In this example, we simply points the stack memories.
If you follow comments and compare them to the outputs, you can easily follow how the pointer can be used in stack memory.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">CStylePointer</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n\n</span><span class="s">==== BASIC C-style RAW POINTER - Declaration ====</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    
    <span class="kt">int</span> <span class="n">int1</span> <span class="o">=</span> <span class="mi">13</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">int2</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="kt">int</span><span class="o">*</span> <span class="n">int1Ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">int1</span><span class="p">;</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">int2Ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">int2</span><span class="p">;</span>

    <span class="c1">// Even if another pointer points to the same value, it points to the same address of int1,</span>
    <span class="c1">// but the pointer location itself is different.</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">int3Ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">int1</span><span class="p">;</span> 

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"int1Ptr address: "</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">int1Ptr</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"int2Ptr address: "</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">int2Ptr</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"int3Ptr address: "</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">int3Ptr</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n\n</span><span class="s">==== BASIC C-style RAW POINTER - Swap Values ====</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Before swap:</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"int1Ptr points to "</span> <span class="o">&lt;&lt;</span> <span class="n">int1Ptr</span> <span class="o">&lt;&lt;</span> <span class="s">" with value: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">int1Ptr</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"int2Ptr points to "</span> <span class="o">&lt;&lt;</span> <span class="n">int2Ptr</span> <span class="o">&lt;&lt;</span> <span class="s">" with value: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">int2Ptr</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="c1">// Swapping values</span>
    <span class="kt">int</span> <span class="n">tempInt</span> <span class="o">=</span> <span class="o">*</span><span class="n">int1Ptr</span><span class="p">;</span>  
    <span class="o">*</span><span class="n">int1Ptr</span> <span class="o">=</span> <span class="o">*</span><span class="n">int2Ptr</span><span class="p">;</span>  
    <span class="o">*</span><span class="n">int2Ptr</span> <span class="o">=</span> <span class="n">tempInt</span><span class="p">;</span>  

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"After swap:</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"int1Ptr points to "</span> <span class="o">&lt;&lt;</span> <span class="n">int1Ptr</span> <span class="o">&lt;&lt;</span> <span class="s">" with value: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">int1Ptr</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"int2Ptr points to "</span> <span class="o">&lt;&lt;</span> <span class="n">int2Ptr</span> <span class="o">&lt;&lt;</span> <span class="s">" with value: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">int2Ptr</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"int3Ptr still points to int1, so its value also changed: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">int3Ptr</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>


    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n\n</span><span class="s">==== BASIC C-style RAW POINTER - 1D Array and Pointer Arithmetic ====</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">array1D</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">arr1DPtr</span> <span class="o">=</span> <span class="n">array1D</span><span class="p">;</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">arr1DPtrAlias</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">array1D</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"arr1DPtr : "</span> <span class="o">&lt;&lt;</span> <span class="n">arr1DPtr</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"arr1DPtrAlias : "</span> <span class="o">&lt;&lt;</span> <span class="n">arr1DPtrAlias</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

    <span class="c1">// Pointer Arithmetic</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Pointer arithmetic:</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"arr1DPtr is at address: "</span> <span class="o">&lt;&lt;</span> <span class="n">arr1DPtr</span> <span class="o">&lt;&lt;</span> <span class="s">" with value: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">arr1DPtr</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">arr1DPtr</span><span class="o">++</span><span class="p">;</span>  
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"After ++arr1DPtr, new address: "</span> <span class="o">&lt;&lt;</span> <span class="n">arr1DPtr</span> <span class="o">&lt;&lt;</span> <span class="s">" with value: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">arr1DPtr</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Value at arr1DPtr + 2: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">(</span><span class="n">arr1DPtr</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" (moves forward by 2 integers)</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="c1">// Iterate through array using pointer arithmetic</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Iterating array using pointer arithmetic: "</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">(</span><span class="n">array1D</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>


    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n\n</span><span class="s">==== BASIC C-style RAW POINTER - 2D Array ====</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">array2D</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">}</span>
    <span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"**array2D points to: "</span> <span class="o">&lt;&lt;</span> <span class="o">**</span><span class="n">array2D</span> <span class="o">&lt;&lt;</span> <span class="s">" (first element: 0)</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"**(array2D + 1) points to: "</span> <span class="o">&lt;&lt;</span> <span class="o">**</span><span class="p">(</span><span class="n">array2D</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" (first element of second row: 5)</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"*((*array2D) + 5) points to: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="n">array2D</span><span class="p">)</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" (linear memory access to second row first element: 5)</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"*(*(array2D + 1) + 2) points to: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">array2D</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" (element at row 1, col 2: 7)</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="c1">// Pointer Aliases for Rows</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">arr2DPtr0</span> <span class="o">=</span> <span class="n">array2D</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">arr2DPtr0Alias</span> <span class="o">=</span> <span class="o">*</span><span class="n">array2D</span><span class="p">;</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">arr2DPtr1</span> <span class="o">=</span> <span class="n">array2D</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"array2D base address: "</span> <span class="o">&lt;&lt;</span> <span class="n">array2D</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"arr2DPtr0 (first row): "</span> <span class="o">&lt;&lt;</span> <span class="n">arr2DPtr0</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"arr2DPtr0Alias (alias for first row): "</span> <span class="o">&lt;&lt;</span> <span class="n">arr2DPtr0Alias</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"arr2DPtr1 (second row): "</span> <span class="o">&lt;&lt;</span> <span class="n">arr2DPtr1</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"array2D[1] (second row): "</span> <span class="o">&lt;&lt;</span> <span class="n">array2D</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"(array2D[0] + 5) (next row start): "</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">array2D</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"(array2D + 1) (pointer to second row): "</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">array2D</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">CStylePointer</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="dynamic-allocation-with-pointers">Dynamic Allocation with Pointers</h2>
<p>When it comes to the dynamic allocation (or heap allocation), the pointer needs developer’s management. Unlike modern managed languages using garbage collections such as Python, JAVA and so on, developers needs to indicate when the memory is deleted explicitly.</p>

<p>In C-style, we use <code class="language-plaintext highlighter-rouge">malloc</code> (which refers to “memory allocate”) for allocating heap memory, and use <code class="language-plaintext highlighter-rouge">free</code> (which refers to “free memory”) for deallocating the existing memory. Those functions are in <code class="language-plaintext highlighter-rouge">stdlib.h</code>.</p>

<blockquote>
  <p>Note - <code class="language-plaintext highlighter-rouge">malloc</code>, <code class="language-plaintext highlighter-rouge">calloc</code>, <code class="language-plaintext highlighter-rouge">realloc</code> and <code class="language-plaintext highlighter-rouge">alloca</code><br />
<code class="language-plaintext highlighter-rouge">malloc</code> is generally used for memory allocation, while <code class="language-plaintext highlighter-rouge">calloc</code> clear the memory first then allocate. <code class="language-plaintext highlighter-rouge">realloc</code> often uses for resize allocation memory. and finally <code class="language-plaintext highlighter-rouge">alloca</code> is stack-heap memory allocation depends on the platforms (OS (that supports which compilers) / architecture).</p>
</blockquote>

<p>In C++ style, we can use C-style allocation, however, we generally use built-in memory allocation keywords: <code class="language-plaintext highlighter-rouge">new</code> and <code class="language-plaintext highlighter-rouge">delete</code>.</p>

<p>In either style, C or C++, A developer must use pointer to access memory and manage the memory with pointer.</p>

<p>Of course the best option is writing code only using stack memory (which is controlled by the code block), however, unfortunately, we generally needs large memory space in most programming.</p>

<p>RAII (Resource Acquisition Is Initialization) pattern might be the best pattern that using heap memory effectively by mimicing the stack behavior (automatic deallocation of memory when the code block is ended and even unexpectedly ended).</p>

<p>In C++, <code class="language-plaintext highlighter-rouge">std::memory</code> like libraries supports RAII pattern such as <code class="language-plaintext highlighter-rouge">std::unique_ptr</code>, <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> and <code class="language-plaintext highlighter-rouge">std::weak_ptr</code>.
In most case, using <code class="language-plaintext highlighter-rouge">std::unique_ptr</code> is effectively used for without concerns, however, there is no free lunch, most big tech companies using C++ have their own <code class="language-plaintext highlighter-rouge">std::memory</code>-like library for their own purposes: some of them are more debuggable or much more safer or much more powerful.</p>

<h2 id="c-style-dynamic-allocation">C-style Dynamic Allocation</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="c1"> // &lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">CStyleDynamicAllocation</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n\n</span><span class="s">==== C-style Dynamic Allocation ====</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="c1">// Allocate memory for an integer</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">intPtr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">intPtr</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Memory allocation failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">*</span><span class="n">intPtr</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Allocated integer value: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">intPtr</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="c1">// Free the allocated memory</span>
    <span class="n">free</span><span class="p">(</span><span class="n">intPtr</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Freed integer memory.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="c1">// Allocate memory for an array of integers</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">arrayPtr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">arrayPtr</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Memory allocation failed for array!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">arrayPtr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Allocated array values: "</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">arrayPtr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="c1">// Free the allocated array memory</span>
    <span class="n">free</span><span class="p">(</span><span class="n">arrayPtr</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Freed array memory.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">CStyleDynamicAllocation</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="c---raii-dynamic-allocation">C++ - RAII Dynamic Allocation</h2>

<p>The following <code class="language-plaintext highlighter-rouge">UniquePtr</code> is mocking of <code class="language-plaintext highlighter-rouge">std::unique_ptr</code> in standard library, that make a pointer delete its occupation of memory automatically when the code block ends.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;functional&gt;</span><span class="c1"> // for C++ style function pointers (callbacks)</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Deleter</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">)&gt;</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">UniquePtr</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Constructor (default deleter uses `delete`)</span>
    <span class="c1">// for default value of deleter, set a normal function that deletes pointer : delete p;</span>
    <span class="k">explicit</span> <span class="n">UniquePtr</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="n">Deleter</span> <span class="n">deleter</span> <span class="o">=</span> <span class="p">[](</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">p</span><span class="p">;</span> <span class="p">})</span>
        <span class="o">:</span> <span class="n">m_Ptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span>
        <span class="p">,</span> <span class="n">m_Deleter</span><span class="p">(</span><span class="n">deleter</span><span class="p">)</span>
        <span class="p">{}</span>

    <span class="c1">// Destructor</span>
    <span class="o">~</span><span class="n">UniquePtr</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_Ptr</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">m_Deleter</span><span class="p">(</span><span class="n">m_Ptr</span><span class="p">);</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[DEBUG] Deleted object at "</span> <span class="o">&lt;&lt;</span> <span class="n">m_Ptr</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Delete Copy Constructor &amp; Copy Assignment</span>
    <span class="n">UniquePtr</span><span class="p">(</span><span class="k">const</span> <span class="n">UniquePtr</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">UniquePtr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">UniquePtr</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

    <span class="c1">// Move Constructor</span>
    <span class="n">UniquePtr</span><span class="p">(</span><span class="n">UniquePtr</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span>
        <span class="o">:</span> <span class="n">m_Ptr</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">m_Ptr</span><span class="p">),</span> <span class="n">m_Deleter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">m_Deleter</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">other</span><span class="p">.</span><span class="n">m_Ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Move Assignment</span>
    <span class="n">UniquePtr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">UniquePtr</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Reset</span><span class="p">();</span> <span class="c1">// Delete current resource</span>
            <span class="n">m_Ptr</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">m_Ptr</span><span class="p">;</span>
            <span class="n">m_Deleter</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">m_Deleter</span><span class="p">);</span>
            <span class="n">other</span><span class="p">.</span><span class="n">m_Ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Overloaded Operators</span>
    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">m_Ptr</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_Ptr</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// Getter</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">Get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_Ptr</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// Reset function</span>
    <span class="kt">void</span> <span class="n">Reset</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">newPtr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_Ptr</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">m_Deleter</span><span class="p">(</span><span class="n">m_Ptr</span><span class="p">);</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[DEBUG] Reset deleted object at "</span> <span class="o">&lt;&lt;</span> <span class="n">m_Ptr</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">m_Ptr</span> <span class="o">=</span> <span class="n">newPtr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Release function (returns the raw pointer and removes ownership)</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">Release</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">T</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">m_Ptr</span><span class="p">;</span>
        <span class="n">m_Ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">m_Ptr</span><span class="p">;</span>
    <span class="n">Deleter</span> <span class="n">m_Deleter</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// for Arrays</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Deleter</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">UniquePtr</span><span class="o">&lt;</span><span class="n">T</span><span class="p">[],</span> <span class="n">Deleter</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Constructor</span>
    <span class="k">explicit</span> <span class="n">UniquePtr</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="n">Deleter</span> <span class="n">deleter</span> <span class="o">=</span> <span class="p">[](</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="k">delete</span><span class="p">[]</span> <span class="n">p</span><span class="p">;</span> <span class="p">})</span>
        <span class="o">:</span> <span class="n">m_Ptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span>
        <span class="p">,</span> <span class="n">m_Deleter</span><span class="p">(</span><span class="n">deleter</span><span class="p">)</span>
    <span class="p">{}</span>

    <span class="c1">// Destructor</span>
    <span class="o">~</span><span class="n">UniquePtr</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_Ptr</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">m_Deleter</span><span class="p">(</span><span class="n">m_Ptr</span><span class="p">);</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[DEBUG] Deleted array at "</span> <span class="o">&lt;&lt;</span> <span class="n">m_Ptr</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Delete Copy Constructor &amp; Copy Assignment</span>
    <span class="n">UniquePtr</span><span class="p">(</span><span class="k">const</span> <span class="n">UniquePtr</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">UniquePtr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">UniquePtr</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

    <span class="c1">// Move Constructor</span>
    <span class="n">UniquePtr</span><span class="p">(</span><span class="n">UniquePtr</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span>
        <span class="o">:</span> <span class="n">m_Ptr</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">m_Ptr</span><span class="p">),</span> <span class="n">m_Deleter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">m_Deleter</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">other</span><span class="p">.</span><span class="n">m_Ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Move Assignment</span>
    <span class="n">UniquePtr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">UniquePtr</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Reset</span><span class="p">();</span>
            <span class="n">m_Ptr</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">m_Ptr</span><span class="p">;</span>
            <span class="n">m_Deleter</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">m_Deleter</span><span class="p">);</span>
            <span class="n">other</span><span class="p">.</span><span class="n">m_Ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Overloaded Operator (array-style access)</span>
    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_Ptr</span><span class="p">[</span><span class="n">index</span><span class="p">];</span> <span class="p">}</span>

    <span class="c1">// Getter</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">Get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_Ptr</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// Reset function</span>
    <span class="kt">void</span> <span class="n">Reset</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">newPtr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_Ptr</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">m_Deleter</span><span class="p">(</span><span class="n">m_Ptr</span><span class="p">);</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[DEBUG] Reset deleted array at "</span> <span class="o">&lt;&lt;</span> <span class="n">m_Ptr</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">m_Ptr</span> <span class="o">=</span> <span class="n">newPtr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Release function</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">Release</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">T</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">m_Ptr</span><span class="p">;</span>
        <span class="n">m_Ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">m_Ptr</span><span class="p">;</span>
    <span class="n">Deleter</span> <span class="n">m_Deleter</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Managing a single object with default deleter</span>
    <span class="n">UniquePtr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">singlePtr</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Single Value: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">singlePtr</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// Managing a single object with a custom deleter</span>
    <span class="n">UniquePtr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">customDelPtr</span><span class="p">(</span>
        <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">99</span><span class="p">),</span>
        <span class="p">[](</span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[DEBUG] Custom deleter called for "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">);</span>

    <span class="c1">// Managing a dynamic array with default deleter</span>
    <span class="n">UniquePtr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span> <span class="n">arrayPtr</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">]{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">});</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Array Values: "</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">arrayPtr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// Resetting a pointer</span>
    <span class="n">singlePtr</span><span class="p">.</span><span class="n">Reset</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">77</span><span class="p">));</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"After Reset: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">singlePtr</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// Transferring ownership</span>
    <span class="n">UniquePtr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span> <span class="n">movedArray</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">arrayPtr</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arrayPtr</span><span class="p">.</span><span class="n">Get</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ownership transferred successfully!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
