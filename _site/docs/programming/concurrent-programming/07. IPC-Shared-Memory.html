<h1 id="shared-memory-ipc">Shared-Memory IPC</h1>

<p>Shared-memory IPC allows multiple tasks to access a common memory segment. This technique is fast because there is no need to copy data between tasks, but it requires proper synchronization mechanisms like semaphores or mutexes to ensure data consistency.</p>

<details open="">
  <summary class="text-delta">
    Table of contents
  </summary>
<ul id="markdown-toc">
  <li><a href="#shared-memory-ipc" id="markdown-toc-shared-memory-ipc">Shared-Memory IPC</a>    <ul>
      <li><a href="#mutex-lock" id="markdown-toc-mutex-lock">Mutex (Lock)</a></li>
      <li><a href="#condition-variable" id="markdown-toc-condition-variable">Condition Variable</a></li>
      <li><a href="#shared-memory" id="markdown-toc-shared-memory">Shared Memory</a>        <ul>
          <li><a href="#characteristics-of-shared-memory" id="markdown-toc-characteristics-of-shared-memory">Characteristics of Shared Memory</a></li>
          <li><a href="#python-example" id="markdown-toc-python-example">Python Example</a></li>
          <li><a href="#c-example" id="markdown-toc-c-example">C++ Example</a></li>
        </ul>
      </li>
      <li><a href="#thread-pool-pattern" id="markdown-toc-thread-pool-pattern">Thread Pool Pattern</a>        <ul>
          <li><a href="#thread-pool-in-python" id="markdown-toc-thread-pool-in-python">Thread Pool in Python</a></li>
          <li><a href="#thread-pool-in-c" id="markdown-toc-thread-pool-in-c">Thread Pool in C++</a></li>
        </ul>
      </li>
      <li><a href="#conclusion" id="markdown-toc-conclusion">Conclusion</a></li>
    </ul>
  </li>
</ul>

</details>

<h2 id="mutex-lock">Mutex (Lock)</h2>
<p>Unlike message-passing IPC, shared memory is not managed by the OS. Therefore, developers must use a <code class="language-plaintext highlighter-rouge">mutex</code> (refers to mutual exclusion, often referred to as a <code class="language-plaintext highlighter-rouge">lock</code>) to prevent simultaneous access to shared resources by multiple threads.</p>

<h2 id="condition-variable">Condition Variable</h2>

<p>Condition variables are a synchronization primitive that allows threads to wait until a specific condition is matched. They are essential for coordinating actions between threads, especially in scenarios where threads need to communicate about the state of shared data. In short, mutexes protect shared data while condition variables allow threads to wait efficiently for changes in that shared data.</p>

<h2 id="shared-memory">Shared Memory</h2>

<p>Shared memory is a region of memory that can be accessed by multiple processes. It enables high-speed data exchange but requires explicit synchronization to prevent data corruption or race conditions.</p>

<pre><code class="language-mermaid"> 
sequenceDiagram
    participant Process A
    participant Mutex
    participant Shared Memory
    participant Process B

    Process A-&gt;&gt;Mutex: Lock Mutex (Access Shared Memory)
    Process A-&gt;&gt;Shared Memory: Write Data (Critical Section)
    Process A-&gt;&gt;Mutex: Unlock Mutex

    Process B-&gt;&gt;Mutex: Lock Mutex (Wait for Process A)
    Process B-&gt;&gt;Shared Memory: Read Data (Critical Section)
    Process B-&gt;&gt;Mutex: Unlock Mutex

</code></pre>

<h3 id="characteristics-of-shared-memory">Characteristics of Shared Memory</h3>
<ol>
  <li><strong>Direct Access</strong><br />
Shared memory involves creating a region of memory in userland that multiple processes or threads can directly access.</li>
  <li><strong>Speed</strong><br />
Shared memory is generally faster than message passing because it avoids the overhead of copying data.</li>
  <li><strong>Developer Responsibility</strong><br />
The OS provides the mechanism to create the shared memory region, but it does not manage concurrent access.</li>
</ol>

<h3 id="python-example">Python Example</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">threading</span>

<span class="n">SHARED_ARR_SIZE</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">SHARED_ARR</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">SHARED_ARR_SIZE</span>
<span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="n">Lock</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">producer</span><span class="p">(</span><span class="n">writing_time</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">thread_name</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="n">current_thread</span><span class="p">().</span><span class="n">name</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">SHARED_ARR_SIZE</span><span class="p">):</span>
        <span class="n">time</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">writing_time</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
            <span class="n">SHARED_ARR</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">thread_name</span><span class="si">}</span><span class="s"> writes index </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s">: </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">consumer</span><span class="p">(</span><span class="n">penalty</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">thread_name</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="n">current_thread</span><span class="p">().</span><span class="n">name</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">SHARED_ARR_SIZE</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">SHARED_ARR</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">data</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">thread_name</span><span class="si">}</span><span class="s">: No data at index </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s">, waiting </span><span class="si">{</span><span class="n">penalty</span><span class="si">}</span><span class="s"> sec"</span><span class="p">)</span>
                <span class="n">time</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">penalty</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">thread_name</span><span class="si">}</span><span class="s"> consumes index </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s">, data: </span><span class="si">{</span><span class="n">data</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
                <span class="k">break</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">consumer_thread</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">"Consumer"</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">consumer</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
    <span class="n">producer_thread</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">"Producer"</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">producer</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,))</span>

    <span class="n">producer_thread</span><span class="p">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">consumer_thread</span><span class="p">.</span><span class="n">start</span><span class="p">()</span>

    <span class="n">producer_thread</span><span class="p">.</span><span class="n">join</span><span class="p">()</span>
    <span class="n">consumer_thread</span><span class="p">.</span><span class="n">join</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="c-example">C++ Example</h3>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">s_NumData</span> <span class="o">=</span><span class="mi">5</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">s_SharedArr</span><span class="p">[</span><span class="n">s_NumData</span><span class="p">];</span>
<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>


<span class="kt">void</span> <span class="nf">ProduceJob</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">producingSeconds</span><span class="p">)</span>
<span class="p">{</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">producingTime</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="n">producingSeconds</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">producingTime</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">idx</span><span class="o">&lt;</span><span class="n">s_NumData</span><span class="p">;</span> <span class="o">++</span><span class="n">idx</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Writing ["</span> <span class="o">&lt;&lt;</span> <span class="n">idx</span> <span class="o">&lt;&lt;</span> <span class="s">"] data </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">s_SharedArr</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ConsumeJob</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">penaltySeconds</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">s_NumData</span><span class="p">;</span> <span class="o">++</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">s_SharedArr</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Consumer read ["</span> <span class="o">&lt;&lt;</span> <span class="n">idx</span> <span class="o">&lt;&lt;</span> <span class="s">"] data: "</span> <span class="o">&lt;&lt;</span> <span class="n">s_SharedArr</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Consumer: No data at index "</span> <span class="o">&lt;&lt;</span> <span class="n">idx</span> <span class="o">&lt;&lt;</span> <span class="s">", waiting "</span> <span class="o">&lt;&lt;</span> <span class="n">penaltySeconds</span> <span class="o">&lt;&lt;</span> <span class="s">" sec</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="n">penaltySeconds</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">idx</span><span class="o">&lt;</span><span class="n">s_NumData</span><span class="p">;</span> <span class="o">++</span><span class="n">idx</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">s_SharedArr</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">numThread</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">threads</span><span class="p">[</span><span class="n">numThread</span><span class="p">];</span>
    <span class="n">threads</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">ProduceJob</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>  
    <span class="n">threads</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">ConsumeJob</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">numThread</span><span class="p">;</span> <span class="o">++</span><span class="n">idx</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">threads</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="thread-pool-pattern">Thread Pool Pattern</h2>

<p>A thread pool consists of multiple worker threads that execute tasks concurrently. These threads share resources, reducing the overhead of creating and destroying threads frequently. Synchronization techniques, such as mutexes and condition variables, help manage access to shared resources efficiently.</p>
<pre><code class="language-mermaid">sequenceDiagram
    participant Client1
    participant Client2
    participant TaskQueue
    participant ThreadPool
    participant Worker1
    participant Worker2

    Client1-&gt;&gt;TaskQueue: Submit Task A
    Client2-&gt;&gt;TaskQueue: Submit Task B
    TaskQueue--&gt;&gt;ThreadPool: Notify New Tasks
    ThreadPool-&gt;&gt;Worker1: Assign Task A
    Worker1-&gt;&gt;Worker1: Process Task A
    ThreadPool-&gt;&gt;Worker2: Assign Task B
    Worker2-&gt;&gt;Worker2: Process Task B
</code></pre>

<h3 id="thread-pool-in-python">Thread Pool in Python</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">Queue</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">from</span> <span class="nn">utils</span> <span class="kn">import</span> <span class="n">Timer</span>

<span class="c1"># typedef
</span><span class="n">Callback</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[...,</span> <span class="bp">None</span><span class="p">]</span>
<span class="n">Task</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Callback</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">Worker</span><span class="p">(</span><span class="n">Thread</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tasks</span><span class="p">:</span><span class="n">Queue</span><span class="p">[</span><span class="n">Task</span><span class="p">]):</span>
        <span class="nb">super</span><span class="p">().</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">tasks</span> <span class="p">:</span> <span class="n">Queue</span> <span class="o">=</span> <span class="n">tasks</span>
    
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">tasks</span><span class="p">.</span><span class="n">empty</span><span class="p">():</span>
                <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">tasks</span><span class="p">.</span><span class="n">get</span><span class="p">()</span>
                <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">tasks</span><span class="p">.</span><span class="n">task_done</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">ThreadPool</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_threads</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">tasks</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">(</span><span class="n">num_threads</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">num_threads</span> <span class="o">=</span> <span class="n">num_threads</span>

        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">num_threads</span><span class="p">):</span>
            <span class="n">worker</span> <span class="o">=</span> <span class="n">Worker</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">tasks</span><span class="p">)</span>
            <span class="n">worker</span><span class="p">.</span><span class="n">setDaemon</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">worker</span><span class="p">.</span><span class="n">start</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">submit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span><span class="n">Callback</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">tasks</span><span class="p">.</span><span class="n">put</span><span class="p">((</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">))</span>
    
    <span class="k">def</span> <span class="nf">wait</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">tasks</span><span class="p">.</span><span class="n">join</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">cpu_waster</span><span class="p">(</span><span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="n">current_thread</span><span class="p">().</span><span class="n">getName</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s"> : doing </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s"> work"</span><span class="p">)</span>
    <span class="n">time</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">num_jobs</span>     <span class="p">:</span> <span class="nb">int</span>   <span class="o">=</span> <span class="mi">20</span>
    <span class="n">num_threads</span>  <span class="p">:</span> <span class="nb">int</span>   <span class="o">=</span> <span class="mi">5</span>
    <span class="n">timer</span>        <span class="p">:</span> <span class="n">Timer</span> <span class="o">=</span> <span class="n">Timer</span><span class="p">()</span>

    <span class="n">pool</span> <span class="o">=</span> <span class="n">ThreadPool</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">=</span> <span class="n">num_threads</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_jobs</span><span class="p">):</span>
        <span class="n">pool</span><span class="p">.</span><span class="n">submit</span><span class="p">(</span><span class="n">cpu_waster</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
    <span class="n">pool</span><span class="p">.</span><span class="n">wait</span><span class="p">()</span>

<span class="k">if</span> <span class="s">"__main__"</span> <span class="o">==</span> <span class="n">__name__</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</code></pre></div></div>
<h3 id="thread-pool-in-c">Thread Pool in C++</h3>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;condition_variable&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">coutMtx</span><span class="p">;</span>

<span class="k">using</span> <span class="n">Task</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">ThreadPool</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">ThreadPool</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">numThreads</span><span class="p">)</span> <span class="o">:</span> <span class="n">mb_Stop</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numThreads</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m_Workers</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">([</span><span class="k">this</span><span class="p">]</span> <span class="p">{</span> <span class="n">workerThread</span><span class="p">();</span> <span class="p">});</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="o">~</span><span class="n">ThreadPool</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m_queueMtx</span><span class="p">);</span>
            <span class="n">mb_Stop</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">m_CV</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">worker</span> <span class="o">:</span> <span class="n">m_Workers</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">worker</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Func</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
    <span class="kt">void</span> <span class="n">Submit</span><span class="p">(</span><span class="n">Func</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">m_queueMtx</span><span class="p">);</span>
            <span class="n">m_Tasks</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Func</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...));</span>
        <span class="p">}</span>
        <span class="n">m_CV</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Wait</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">m_WaitMtx</span><span class="p">);</span>
        <span class="n">m_CVWait</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="p">[</span><span class="k">this</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_Tasks</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="p">});</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="kt">void</span> <span class="n">workerThread</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Task</span> <span class="n">task</span><span class="p">;</span>
            <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m_queueMtx</span><span class="p">);</span>
                <span class="n">m_CV</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="p">[</span><span class="k">this</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="n">mb_Stop</span> <span class="o">||</span> <span class="o">!</span><span class="n">m_Tasks</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="p">});</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">mb_Stop</span> <span class="o">&amp;&amp;</span> <span class="n">m_Tasks</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
                    <span class="k">return</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">task</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">m_Tasks</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>
                <span class="n">m_Tasks</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

                <span class="k">if</span><span class="p">(</span><span class="n">m_Tasks</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
                    <span class="n">m_CVWait</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">task</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">m_Workers</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;</span> <span class="n">m_Tasks</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m_queueMtx</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">m_CV</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m_WaitMtx</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">m_CVWait</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">mb_Stop</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">cpu_waster</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
    <span class="p">{</span>   
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">coutMtx</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" : doing "</span> <span class="o">&lt;&lt;</span> <span class="n">idx</span> <span class="o">&lt;&lt;</span> <span class="s">" work"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">numJobs</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">numThreads</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="n">ThreadPool</span> <span class="n">pool</span><span class="p">(</span><span class="n">numThreads</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">numJobs</span><span class="p">;</span> <span class="o">++</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pool</span><span class="p">.</span><span class="n">Submit</span><span class="p">(</span><span class="n">cpu_waster</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">pool</span><span class="p">.</span><span class="n">Wait</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>
<p>Inter-Process Communication (IPC) is fundamental to concurrent programming, allowing processes and threads to coordinate efficiently. Shared-memory IPC techniques provide high performance but require great caution from developers to ensure safe code because OS merely manages the shared memory control in userland.</p>

