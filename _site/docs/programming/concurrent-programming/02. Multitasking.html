<h1 id="multitasking">Multitasking</h1>

<p>Multitasking is the concept that encompasses multi-threading and multi-processing to achieve concurrent program executions.</p>

<details open="">
  <summary class="text-delta">
    Table of contents
  </summary>
<ul id="markdown-toc">
  <li><a href="#multitasking" id="markdown-toc-multitasking">Multitasking</a>    <ul>
      <li><a href="#multiprogramming" id="markdown-toc-multiprogramming">Multiprogramming</a></li>
      <li><a href="#multitasking-is-a-logical-extension-of-multiprogramming" id="markdown-toc-multitasking-is-a-logical-extension-of-multiprogramming">Multitasking is a logical extension of Multiprogramming</a>        <ul>
          <li><a href="#preemptive-multitasking" id="markdown-toc-preemptive-multitasking">Preemptive Multitasking</a></li>
          <li><a href="#context-switching" id="markdown-toc-context-switching">Context Switching</a></li>
          <li><a href="#cooperative-multitasking" id="markdown-toc-cooperative-multitasking">Cooperative Multitasking</a></li>
        </ul>
      </li>
      <li><a href="#multitasking-oss" id="markdown-toc-multitasking-oss">Multitasking OSs</a>        <ul>
          <li><a href="#task-isolation" id="markdown-toc-task-isolation">Task Isolation</a></li>
          <li><a href="#task-scheduling-cpu-scheduling" id="markdown-toc-task-scheduling-cpu-scheduling">Task Scheduling (CPU Scheduling)</a></li>
        </ul>
      </li>
      <li><a href="#conclusion" id="markdown-toc-conclusion">Conclusion</a></li>
    </ul>
  </li>
</ul>

</details>

<h2 id="multiprogramming">Multiprogramming</h2>

<p>Multiprogramming is a technique that allows multiple programs to reside in memory simultaneously, enabling the CPU to switch between the programs when the current program is waiting for I/O operations. This maximizes CPU utilization by reducing idle time. However, in multiprogramming, context switches occur primarily when a program voluntarily yields control (e.g., during I/O waits).</p>

<h2 id="multitasking-is-a-logical-extension-of-multiprogramming">Multitasking is a logical extension of Multiprogramming</h2>

<p>Multitasking, as a logical extension, introduces <strong>time-sharing</strong> through <strong>frequent context switches</strong> based on a fixed time quantum and some supportive data structure (i.e. multi-level priority queue). This mechanism is called as <strong>time-scheduling</strong> which is a basic building block in the modern OS. Time sharing creates the illusion of simultaneous execution, allowing users to interact with multiple tasks concurrently. While multiprogramming focuses on CPU efficiency, multitasking emphasizes responsiveness and interactive user experiences. In multi-tasking systems, the CPU executes multiple jobs by switching among them rapidly, ensuring fair resource allocation and seamless user interaction.</p>

<blockquote>
  <p><strong>Note: CPU-bound vs I/O-bound</strong>   <br />
Applications often consist of intensive CPU work, but they may also interact with I/O devices like keyboards, disks, or networks to read inputs or produce outputs.  <br />
<strong>CPU-bound</strong>     <br />
An application is CPU-bound if its performance primarily depends on CPU speed. Such applications would run faster with a more powerful CPU.     <br />
<strong>I/O-bound</strong>     <br />
An application is I/O-bound if its performance depends on the speed of I/O subsystems (e.g., disk, network). These applications benefit from faster I/O devices or optimized I/O operations.</p>
</blockquote>

<h3 id="preemptive-multitasking">Preemptive Multitasking</h3>
<p>Preemptive multitasking allows the operating system to forcibly interrupt a running task to allocate CPU time to another task. This is typically achieved through time-slicing, where each task runs for a predefined interval before the OS preempts it. Preemption ensures fair CPU usage, prevents monopolization by a single task, and enhances system responsiveness. Modern operating systems (e.g., Windows, Linux) use this approach to manage multiple processes and threads efficiently.</p>

<h3 id="context-switching">Context Switching</h3>
<p>Context switching is the process of saving the state (e.g., registers, program counter) of a running task and restoring the state of another task. While essential for multitasking, it introduces overhead as the CPU spends time managing switches rather than executing tasks. Optimizations like hardware-supported context switching and efficient scheduling algorithms minimize this overhead.</p>

<h3 id="cooperative-multitasking">Cooperative Multitasking</h3>
<p>In cooperative multitasking, tasks voluntarily yield control to the scheduler, allowing other tasks to run. The OS cannot forcibly preempt a task; instead, tasks must explicitly relinquish control (e.g., via yield() calls). This approach requires careful programming, as a misbehaving task that fails to yield can block the entire system. Cooperative multitasking was used in early systems like Windows 3.x and classic Mac OS. It is also prevalent in runtime environments for asynchronous programming (e.g., Python’s asyncio, JavaScript’s event loop).</p>

<h2 id="multitasking-oss">Multitasking OSs</h2>

<h3 id="task-isolation">Task Isolation</h3>
<p>Task isolation ensures that tasks operate independently without interfering with each other. Modern OSs achieve this through virtual memory, memory protection, and separate address spaces. For example, processes run in isolated memory spaces, while threads within a process share memory but synchronize access to avoid concurrency issues. Isolation enhances security and stability, preventing crashes in one task from affecting others.</p>

<h3 id="task-scheduling-cpu-scheduling">Task Scheduling (CPU Scheduling)</h3>
<p>Task scheduling determines how the OS allocates CPU time to tasks. Common algorithms include:</p>
<ul>
  <li>Round Robin: Tasks execute in fixed time slices.</li>
  <li>Priority-Based: Higher-priority tasks run first.</li>
  <li>Shortest Job Next (SJN): Prioritizes tasks with the smallest execution time.
Modern schedulers dynamically adjust priorities and use hybrid strategies to optimize throughput, latency, and fairness.</li>
</ul>

<h2 id="conclusion">Conclusion</h2>
<p>Multi-tasking is foundational to modern computing, enabling concurrent execution of tasks through preemptive or cooperative strategies. Preemptive multitasking, driven by time-slicing and context switching, ensures responsiveness and fairness in general-purpose OSs. Cooperative multitasking, while less common today, remains relevant in specific asynchronous programming paradigms. Understanding CPU-bound vs I/O-bound tasks helps optimize performance, while advancements in task isolation and scheduling continue to enhance system efficiency and reliability.</p>
