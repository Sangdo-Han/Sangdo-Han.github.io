---
layout: default
title: 11. Synchronization
parent: Concurrent Programming
tags: 
  - concurrent programming
  - multithreading
  - multiprocessing
  - synchronization
  - C++
  - C
  - race condition
---

# Synchronization
Talking about the race condition and the synchronization methods.

<details open markdown="block">
  <summary>
    Table of contents
  </summary>
  {: .text-delta }
- . TOC
{:toc}
</details>

## Race condition

<p><img src="https://sangdo-han.github.io/docs/programming/concurrent-programming/images/11_critical_section.png" /></p>

When using the shared memory / resources, race condition can occur. In the diagram `Thread1` and `Thread2` tries to increase the shared variable `a`, but if the data captured both `Thread 1` and `Thread 2` and not returned yet from those threads, in this case, we can see the unexpected behavior that `a=3` not `a=4`. In this case, attempting to accessing the shared variable `a` causes this race, and this kind of operation is called as a `critical section`.

```cpp
#include <array>
#include <chrono>
#include <iostream>
#include <thread>

#include "Timer.h"

void IncreaseA(const int numIter, int* shared_ptr)
{
   int i = 0;
   using namespace std::chrono_literals;
   for (int i = 0; i < numIter; ++i) {
       ++(*shared_ptr);
       std::this_thread::sleep_for(10us);
   }
}

int main()
{
  
   Timer timer;
   constexpr int NUM_THREADS = 4;
   constexpr int NUM_ITERATIONS = 10'000;

   int shared_value = 0;
  
   std::array<std::thread, NUM_THREADS> threads;
  
   for(int i=0; i<NUM_THREADS; ++i)
   {
       threads[i] = std::thread(IncreaseA, NUM_ITERATIONS, &shared_value);
   }

   for(int i=0; i<NUM_THREADS; ++i)
   {
       threads[i].join();
   }
  
   std::cout << shared_value << "\n";

}

```

## Traditional Solution: Lock
Once one Thread enters a Critical Section to perform a task, a lock prevents other Threads from performing that task.

- Lock: An abstract concept for a critical section. It refers to a mechanism that prevents all processes from touching resources or code blocks that one or more threads are simultaneously accessing.

- Mutex: It is one of the concrete tools that implement the Lock concept. As its name implies, it is the most representative way to allow only one thread to access at a given time by providing mutual exclusion

## Modern Solution - Lockfree : Atomic operations
In modern computers, `atomic` operations supports in hardware / OS levels.
These `atomic operation` ensures the un-breakable operations such as ordering memories in store and load memories, CAS (compare and swap), and TAS (test and set).