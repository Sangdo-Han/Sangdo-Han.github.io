---
layout: default
title: 03. Threads
parent: Concurrent Programming
nav_order: 2
tags: 
  - concurrent programming
  - multi-threading
  - multi-processing
  - asynchronous programming
  - C++
  - C
  - python
---


# Thread

A thread is indeed an independent sequence of instructions within a process.  It's the smallest unit of execution that can be scheduled by the OS.


<details open markdown="block">
  <summary>
    Table of contents
  </summary>
  {: .text-delta }
- . TOC
{:toc}
</details>

## More specifically

A thread is the smallest sequence of instructions that can be executed independently. Each thread has its own stack and registers, but it shares the same memory with other threads in the same process. This means threads in a process can access the same data, but they cannot modify each other's register data without proper synchronization.

In short, each thread operates independently, unaware of the others unless explicitly designed to interact.

## Advantages and Disadvantages

### Pros - memory / communication overhead

Threads have much less memory overhead than the standard `fork()` function as the parent thread is not copied - threads use the same process.

Also, By just accessing the shared address space of their parent process, all the threads in a process can communicate with the same data: any changes by a single thread is immediately available to the others.

In tasks like graphics programming (e.g., shader programming), threads are often more convenient than processes.

### Cons - developer's burden on synchronization.

Unlike process, OS does not provide complete independence. This is because all threads in a process uses the same shared resources, if one crashes or corrupted, the others will be affected. Therefore, developer needs to handle with synchronization techniques.


## Naive usage in C++

Here's naive implementation of threading in C++.

```cpp
#include <iostream>
#include <chrono>
#include <thread>
#include <unistd.h>
#include <string>
#include <sys/types.h>
// #include <mutex> <-- in the future ! // lock

void threadJob(int idx, int sleepSeconds)
{
    pid_t threadPID = getpid();
    std::thread::id threadID = std::this_thread::get_id();
    std::cout << threadID << " in PID (" << threadPID << ")" << "\n";
    std::this_thread::sleep_for(std::chrono::seconds(sleepSeconds));
}

int main()
{
    const int NUM_THREAD = 5;
    const int SLEEP_SECONDS = 2;

    std::thread threads[NUM_THREAD];

    for (int i=0; i < NUM_THREAD; i++)
    {
        threads[i] = std::thread(threadJob, i, SLEEP_SECONDS);
    }

    for ( int i=0; i < NUM_THREAD; i++)
    {
        threads[i].join();
    }

}
```

The code above, system print call won't work properly because of absence of locks - Race condition

About this issue, we will cover later post.